diff --git a/src/physics/include/grins/inc_navier_stokes_adjoint_stab.h b/src/physics/include/grins/inc_navier_stokes_adjoint_stab.h
index 54cae43..334d30d 100644
--- a/src/physics/include/grins/inc_navier_stokes_adjoint_stab.h
+++ b/src/physics/include/grins/inc_navier_stokes_adjoint_stab.h
@@ -42,6 +42,11 @@ namespace GRINS
 					  AssemblyContext& context,
 					  CachedValues& cache );
 
+
+    virtual void element_constraint( bool compute_jacobian,
+                                     AssemblyContext& context,
+                                     CachedValues& cache );
+
     virtual void mass_residual( bool compute_jacobian,
 				AssemblyContext& context,
 				CachedValues& cache );
diff --git a/src/physics/src/inc_navier_stokes_adjoint_stab.C b/src/physics/src/inc_navier_stokes_adjoint_stab.C
index a903054..9ac36e4 100644
--- a/src/physics/src/inc_navier_stokes_adjoint_stab.C
+++ b/src/physics/src/inc_navier_stokes_adjoint_stab.C
@@ -57,17 +57,12 @@ namespace GRINS
 #endif
 
     // The number of local degrees of freedom in each variable.
-    const unsigned int n_p_dofs = context.get_dof_indices(this->_flow_vars.p_var()).size();
     const unsigned int n_u_dofs = context.get_dof_indices(this->_flow_vars.u_var()).size();
 
     // Element Jacobian * quadrature weights for interior integration.
     const std::vector<libMesh::Real> &JxW =
       context.get_element_fe(this->_flow_vars.u_var())->get_JxW();
 
-    // The pressure shape functions at interior quadrature points.
-    const std::vector<std::vector<libMesh::RealGradient> >& p_dphi =
-      context.get_element_fe(this->_flow_vars.p_var())->get_dphi();
-
     /*
       const std::vector<std::vector<libMesh::Real> >& u_phi =
       context.get_element_fe(this->_flow_vars.u_var())->get_phi();
@@ -85,14 +80,12 @@ namespace GRINS
     if(this->_dim == 3)
       Fw = &context.get_elem_residual(this->_flow_vars.w_var()); // R_{w}
 
-    libMesh::DenseSubVector<libMesh::Number> &Fp = context.get_elem_residual(this->_flow_vars.p_var()); // R_{p}
-
     unsigned int n_qpoints = context.get_element_qrule().n_points();
 
+    libMesh::FEBase* fe = context.get_element_fe(this->_flow_vars.u_var());
+
     for (unsigned int qp=0; qp != n_qpoints; qp++)
       {
-        libMesh::FEBase* fe = context.get_element_fe(this->_flow_vars.u_var());
-
         libMesh::RealGradient g = this->_stab_helper.compute_g( fe, context, qp );
         libMesh::RealTensor G = this->_stab_helper.compute_G( fe, context, qp );
 
@@ -117,13 +110,6 @@ namespace GRINS
         libMesh::RealGradient RM_s = this->_stab_helper.compute_res_momentum_steady( context, qp, this->_rho, this->_mu );
         libMesh::Real RC = this->_stab_helper.compute_res_continuity( context, qp );
 
-        // Now a loop over the pressure degrees of freedom.  This
-        // computes the contributions of the continuity equation.
-        for (unsigned int i=0; i != n_p_dofs; i++)
-          {
-            Fp(i) += tau_M*RM_s*p_dphi[i][qp]*JxW[qp];
-          }
-
         for (unsigned int i=0; i != n_u_dofs; i++)
           {
             libMesh::Real test_func = this->_rho*U*u_gradphi[i][qp] + 
@@ -131,13 +117,13 @@ namespace GRINS
 
             //libMesh::RealGradient zeroth_order_term = - _rho*u_phi[i][qp]*(grad_u + grad_v + grad_w);
 
-            Fu(i) += ( tau_M*RM_s(0)*test_func - tau_C*RC*u_gradphi[i][qp](0) )*JxW[qp];
+            Fu(i) += ( -tau_M*RM_s(0)*test_func - tau_C*RC*u_gradphi[i][qp](0) )*JxW[qp];
 
-            Fv(i) += ( tau_M*RM_s(1)*test_func - tau_C*RC*u_gradphi[i][qp](1) )*JxW[qp];
+            Fv(i) += ( -tau_M*RM_s(1)*test_func - tau_C*RC*u_gradphi[i][qp](1) )*JxW[qp];
 
             if(this->_dim == 3)
               {
-                (*Fw)(i) += ( tau_M*RM_s(2)*test_func - tau_C*RC*u_gradphi[i][qp](2) )*JxW[qp];
+                (*Fw)(i) += ( -tau_M*RM_s(2)*test_func - tau_C*RC*u_gradphi[i][qp](2) )*JxW[qp];
               }
           }
 
@@ -149,6 +135,64 @@ namespace GRINS
     return;
   }
 
+    void IncompressibleNavierStokesAdjointStabilization::element_constraint( bool /*compute_jacobian*/,
+                                                                             AssemblyContext& context,
+                                                                             CachedValues& /*cache*/ )
+  {
+#ifdef GRINS_USE_GRVY_TIMERS
+    this->_timer->BeginTimer("IncompressibleNavierStokesAdjointStabilization::element_constraint");
+#endif
+
+    // The number of local degrees of freedom in each variable.
+    const unsigned int n_p_dofs = context.get_dof_indices(this->_flow_vars.p_var()).size();
+
+    // Element Jacobian * quadrature weights for interior integration.
+    const std::vector<libMesh::Real> &JxW =
+      context.get_element_fe(this->_flow_vars.u_var())->get_JxW();
+
+    // The pressure shape functions at interior quadrature points.
+    const std::vector<std::vector<libMesh::RealGradient> >& p_dphi =
+      context.get_element_fe(this->_flow_vars.p_var())->get_dphi();
+
+    libMesh::DenseSubVector<libMesh::Number> &Fp = context.get_elem_residual(this->_flow_vars.p_var()); // R_{p}
+
+    unsigned int n_qpoints = context.get_element_qrule().n_points();
+
+    libMesh::FEBase* fe = context.get_element_fe(this->_flow_vars.u_var());
+
+    for (unsigned int qp=0; qp != n_qpoints; qp++)
+      {
+        libMesh::RealGradient g = this->_stab_helper.compute_g( fe, context, qp );
+        libMesh::RealTensor G = this->_stab_helper.compute_G( fe, context, qp );
+
+        libMesh::RealGradient U( context.interior_value( this->_flow_vars.u_var(), qp ),
+                                 context.interior_value( this->_flow_vars.v_var(), qp ) );
+        if( this->_dim == 3 )
+          {
+            U(2) = context.interior_value( this->_flow_vars.w_var(), qp );
+          }
+
+        libMesh::Real tau_M = this->_stab_helper.compute_tau_momentum( context, qp, g, G, this->_rho, U, this->_mu, this->_is_steady );
+
+        libMesh::RealGradient RM_s = this->_stab_helper.compute_res_momentum_steady( context, qp, this->_rho, this->_mu );
+
+        // Now a loop over the pressure degrees of freedom.  This
+        // computes the contributions of the continuity equation.
+        for (unsigned int i=0; i != n_p_dofs; i++)
+          {
+            Fp(i) += tau_M*RM_s*p_dphi[i][qp]*JxW[qp];
+          }
+
+      }
+
+#ifdef GRINS_USE_GRVY_TIMERS
+    this->_timer->EndTimer("IncompressibleNavierStokesAdjointStabilization::element_constraint");
+#endif
+
+    return;
+  }
+
+
   void IncompressibleNavierStokesAdjointStabilization::mass_residual( bool /*compute_jacobian*/,
                                                                       AssemblyContext& context,
                                                                       CachedValues& /*cache*/ )
diff --git a/src/physics/src/inc_navier_stokes_stab_helper.C b/src/physics/src/inc_navier_stokes_stab_helper.C
index 6835a36..b83eb3b 100644
--- a/src/physics/src/inc_navier_stokes_stab_helper.C
+++ b/src/physics/src/inc_navier_stokes_stab_helper.C
@@ -169,7 +169,7 @@ namespace GRINS
         divGradU  = this->div_GradU( hess_u, hess_v, hess_w );
       }
 
-    return -rhoUdotGradU - grad_p + mu*divGradU;
+    return rhoUdotGradU + grad_p - mu*divGradU;
   }
 
   libMesh::RealGradient IncompressibleNavierStokesStabilizationHelper::compute_res_momentum_transient( AssemblyContext& context, unsigned int qp, const libMesh::Real rho ) const
